import torch
import matplotlib.pyplot as plt
import matplotlib

def target_function(x):
    return 2**x * torch.sin(2**-x)

class RegressionNet(torch.nn.Module):
  def __init__(self):
    super(RegressionNet,self).__init__()
    self.fc1 = torch.nn.Linear(1,50)
    self.act1 = torch.nn.Sigmoid()
    self.fc2 = torch.nn.Linear(50,25)
    self.act2 = torch.nn.Sigmoid()
    self.fc3 = torch.nn.Linear(25,1)
    self.act3 = torch.nn.Tanh()

  def forward(self,x):
    x = self.fc1(x)
    x = self.act1(x)
    x = self.fc2(x)
    x = self.act2(x)
    x = self.fc3(x)
    x= self.act3(x)
    return x

net = RegressionNet()

def predict(net,x,y):
  y_pred = net.forward(x)

  plt.figure(figsize=[12,5])

  plt.plot(x.numpy(), y.numpy(), marker ='o',label = 'Source function' )
  plt.plot(x.numpy(), y_pred.data.numpy(), 'ro', label = 'Prediction')

  plt.legend(loc = 'upper left')
  plt.xlabel('X')
  plt.ylabel('Y') 
  
  def metric(pred, target):
   return (pred - target).abs().mean()
   
   x_train =  torch.linspace(-10, 5, 100)
y_train = target_function(x_train)
noise = torch.randn(y_train.shape) / 20.
y_train = y_train + noise
x_train.unsqueeze_(1)
y_train.unsqueeze_(1)

x_validation = torch.linspace(-10, 5, 100)
y_validation = target_function(x_validation)
x_validation.unsqueeze_(1)
y_validation.unsqueeze_(1)
print('')

optimizer = torch.optim.Adam(net.parameters(), lr=0.01)

def loss(y_pred,y_target):
  ABS = abs(y_pred - y_target)
  return ABS.mean()
  
  for epoch_index in range(5000):
  optimizer.zero_grad()

  y_pred = net.forward(x_train)
  loss_val = loss(y_pred,y_train)

  loss_val.backward()
  optimizer.step()

predict(net,x_validation,y_validation)

metric(y_pred,y_train)
